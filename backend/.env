import Joi from "joi";
import path from "path";
import { fileTypeFromFile } from "file-type";
import { generateOtp, generateToken } from "../utility/auth/authHelpers.js";
import {
  errorHandler400,
  errorHandler401,
  errorHandler403,
  errorHandler404,
  successHandler,
} from "../middlewares/responseHandlers.js";
import { User } from "../models/userSchema.js";
import { validationErrors } from "../config/helpers.js";
import { coachVerification, tellUsAbout } from "../models/coachSchema.js";
import { s3ImageUpload } from "../utility/s3/aws.js";
import { sendMessage } from "../utility/twilio/sendMessage.js";
import mongoose from "mongoose";
import { forgotPassword } from "../utility/mail/Auth/forgotPassword.js";
import { emailVerification } from "../utility/mail/Auth/emailVerification.js";
import { mailBox } from "../config/mailBox.js";
import crypto from "crypto";
import { writeData } from "../utility/firebase/firebaseDBFunctions.js";
import {admin} from "../utility/firebase/firebaseConfigure.js"
// import sendPushNotification from "../utility/notifications/index.js";

// register User;
const registerUser = async (req, res) => {
  const {
    name,
    email,
    phone_number,
    password,
    confirm_password,
    role,
    credentialsProvider,
  } = req.body;
  if(credentialsProvider==="email"&&!phone_number){
    errorHandler400(res, "phone_number is a require field")
  };
  const registerSchema = Joi.object({}).keys({
    name: Joi.string().min(3).required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(5).required(),
    confirm_password: Joi.string().min(5).required(),
    role: Joi.string().min(3).required(),
    credentialsProvider: Joi.string().required(),
  });
  const { error } = registerSchema.validate({
    name,
    email,
    password,
    confirm_password,
    role,
    credentialsProvider,
  });
  if (error) {
    errorHandler400(res, error?.details[0].message);
    return;
  }
  if (password !== confirm_password) {
    errorHandler400(res, "password and confirm password must be matched!");
    return;
  }
  const existedUser = await User.findOne({ email });
  if (existedUser) {
    errorHandler400(res, "user with this email already registered");
    return;
  }
  try {
    const registerUser = await User.create({
      name,
      email,
      phone_number,
      password,
      role,
      isUserVerified: false,
      credentialsProvider,
    });
    if (registerUser) {
      const token = generateToken(registerUser._id);
      if(await registerUser.credentialsProvider!=="email"){
        await User.findByIdAndUpdate(registerUser._id, {isEmailVerified:true})
      }
      successHandler(res, { name, email, phone_number, password, role, token });
    }
  } catch (error) {
    errorHandler400(res, error);
  }
};
// OTP Verification
const sentOTP = async (req, res) => {
  var { phoneNumber } = req.body;
  const otp = generateOtp();
  console.log("@111", typeof otp);
  try {
    if (!phoneNumber) return errorHandler401(res, "phone number missing");
    // res.send({ phoneNumber });
    // return;
    const otpSentStatus = await sendMessage(
      phoneNumber,
      `Your verification code is ${otp}`
    );
    let expire = new Date().getTime() + process.env.OTP_EXP * 60000;
    req.session.otp = otp;
    req.session.phoneNumber = phoneNumber;
    req.session.expire = expire;
    await req.session.save();
    if (otpSentStatus.success) {
      successHandler(res, otpSentStatus.data);
      return;
    } else {
      errorHandler400(res, otpSentStatus.error);
      return
    }
  } catch (error) {
    errorHandler401(res, error);
  }
};
const verifyOTP = async (req, res) => {
  const currentUser = req.currentUser;
  try {
    let { otp } = req.body;
    console.log("bodyOTP:", otp);
    if (!otp) return errorHandler404(res, "Enter OTP");
    let month = 3600000 * 24 * 30;
    req.session.cookie.expires = new Date(Date.now() + month);
    let expire = new Date().getTime();
    if (expire > req.session.expire || !req.session.otp)
      return errorHandler404(res, "otp expired");
    if (parseInt(req.session.otp) !== parseInt(otp))
      return errorHandler404(res, "Invalid otp ");

    req.session.otp = undefined;
    req.session.phoneNumber = undefined;
    req.session.cookie.maxAge = new Date(Date.now() + month * 24);
    await req.session.save();
    const UpdateUserOTPStatus = await User.findByIdAndUpdate(
      currentUser._id,
      {
        isPhoneNumberVerified: true,
        phone_number:req.session.phoneNumber
      },
      { new: true }
    );
    req.session.phoneNumber = undefined;
    await req.session.save()
    return successHandler(res, UpdateUserOTPStatus);
  } catch (error) {
    errorHandler400(res, error);
  }
};
// const loginUser = async (req, res) => {
//   // latLng is an array, passed like {latLng=5782348, 5783656}
//   const { email, password, latLng, role } = req.body;
//   const registerSchema = Joi.object({}).keys({
//     email: Joi.string().email().required(),
//     password: Joi.string().min(5).required(),
//     role: Joi.string().required(),
//   });
//   const { error } = registerSchema.validate({ email, password, role });
//   if (error) {
//     errorHandler400(res, error?.details[0].message);
//     return;
//   }
//   const user = await User.findOne({ email });
//   if (!user) return errorHandler404(res, "user not found");
//   if (role !== user.role)
//     return errorHandler400(res, "trying to login with wrong role");
//   if (user && (await user.matchPassword(password))) {
//     const token = generateToken(user._id);
//     if (latLng) {
//       const userWithLatLngs = await User.findByIdAndUpdate(
//         user._id,
//         { latLng: latLng },
//         { new: true }
//       );
//     }
//     successHandler(res, { user, token });
//   } else {
//     errorHandler401(res, "Invalid credentials");
//   }
// };

const loginUser = async (req, res) => {
  const { email, password, latLng, role } = req.body;
  const registerSchema = Joi.object({}).keys({
    email: Joi.string().email().required(),
    password: Joi.string().min(5).required(),
    role: Joi.string().required(),
  });
  const { error } = registerSchema.validate({ email, password, role });
  if (error) {
    errorHandler400(res, error?.details[0].message);
    return;
  }
  const user = await User.findOne({ email });
  if (!user) return errorHandler404(res, "user not found");
  if (role !== user.role)
    return errorHandler400(res, "trying to login with wrong role");
  if (user && (await user.matchPassword(password))) {
    const token = generateToken(user._id);
    if (latLng) {
      const userWithLatLngs = await User.findByIdAndUpdate(
        user._id,
        { latLng: latLng },
        { new: true }
      );
      
    }

    let pushToken=`fa_uTBCgRSG_XBWkgix1-Q:APA91bFm9iPmYnp0eqHt1SSV2RQQS50hz6KY7fKfFesNTqnkLJdDvCYfxEUkVvD0qjUj4GjIofRbc5aRyItgx7O_kiKJkWjS5SeZL3AUy0Jy5zePerBBYK1VME4SaUCko3i2jcVmVjGt`
    // let pushToken=req.body.FMCToken

    // if (pushToken) {
    //   const message = {
    //     notification: {
    //       title: 'Login Successfully',
    //       body: `Welcome back!`,
    //     },
    //     data:{},
    //     token: pushToken,
    //   };

    //   try {
    //     await admin.messaging().send(message);
        
    //     console.log('Push notification sent successfully');
    //   } catch (error) {
    //     console.error('Error sending push notification', error);
    //   }
    // }
    await sendPushNotification(pushToken);

    successHandler(res, { user, token });


  } else {
    errorHandler401(res, "Invalid credentials");
  }
};

const coachVerificationController = async (req, res) => {
  const currentUser = req.currentUser;
  const { profile_picture, cv } = req.files;
  if (!profile_picture || !cv)
    return errorHandler400(
      res,
      "CV and Profile Picture is type files and required!"
    );
  const { first_lastname, dob, address, qualifications, website_link, zipCode } =
    req.body;
  let uploadProfilePicture;
  let coachCV;
  if (profile_picture && cv) {
    uploadProfilePicture = await s3ImageUpload(profile_picture[0], "images");
    coachCV = await s3ImageUpload(cv[0], "docs");
  }
  const coachVerificationSchema = Joi.object({}).keys({
    first_lastname: Joi.string().required(),
    dob: Joi.string().required(),
    address: Joi.string().required(),
    qualifications: Joi.string().required(),
    zipCode:Joi.number().required(),
  });
  const { error } = coachVerificationSchema.validate({
    first_lastname,
    dob,
    address,
    qualifications,
    zipCode
  });
  if (error) {
    errorHandler400(res, error?.details[0]?.message);
    return;
  }
  if (currentUser.role !== "coach") {
    errorHandler401(res, "first register yourself as coach");
    return;
  }
  try {
    const saveCoach = await coachVerification.create({
      profile_picture: uploadProfilePicture.Location,
      first_lastname,
      dob,
      address,
      qualifications,
      cv: coachCV.Location,
      website_link,
      coach_registration: currentUser._id,
      zipCode
    });
    if (saveCoach) {
      const savedCoachInDB = await User.findByIdAndUpdate(
        currentUser._id,
        {
          coachVerification: saveCoach._id,
        },
        { new: true }
      );
      successHandler(res, savedCoachInDB);
      return;
    } else {
      errorHandler400(res, "error while verification the coach");
      return;
    }
  } catch (error) {
    errorHandler400(res, error);
  }
};

// tells us about section
const tellUsAboutController = async (req, res) => {
  const profile_picture = req.file;
  if (!profile_picture)
    return errorHandler400(res, "Profile Picture is a required field");
  const currentUser = req?.currentUser;
  console.log("@@@currentUser", currentUser);
  const {
    first_name,
    last_name,
    age,
    gender,
    height,
    weight,
    goal,
    preferredEatingStyle,
    foodAlergies,
  } = req.body;
  const tellUsSchema = Joi.object({}).keys({
    first_name: Joi.string().required(),
    last_name: Joi.string().required(),
    age: Joi.number().required(),
    gender: Joi.string().required(),
    height: Joi.string().required(),
    weight: Joi.string().required(),
    goal: Joi.string().required(),
    preferredEatingStyle: Joi.string().required(),
    foodAlergies: Joi.string().required(),
  });
  const { error } = tellUsSchema.validate({
    first_name,
    last_name,
    age,
    gender,
    height,
    weight,
    goal,
    preferredEatingStyle,
    foodAlergies,
  });
  let userProfilePicture;
  if (profile_picture) {
    userProfilePicture = await s3ImageUpload(profile_picture, "images");
  }
  if (error) {
    errorHandler400(res, error?.details[0]?.message);
    return;
  }
  try {
    const saveUser = await tellUsAbout.create({
      profile_picture: userProfilePicture.Location,
      first_name,
      last_name,
      age,
      gender,
      height,
      weight,
      goal,
      preferredEatingStyle,
      foodAlergies,
      registeredUser: currentUser._id,
    });
    if (saveUser) {
      const tellUsUser = await User.findByIdAndUpdate(
        currentUser._id,
        {
          tellUsAbout: saveUser._id,
        },
        { new: true }
      );
      successHandler(res, tellUsUser);
    } else {
      errorHandler400(res, "something went wrong");
    }
  } catch (error) {
    errorHandler400(res, error);
  }
};
const getProfile = async (req, res) => {
  let currentUserProfile;
  currentUserProfile = req?.currentUser;
  try {
    if (currentUserProfile.tellUsAbout) {
      // await writeData("user", {
      //   name: "sir Hassan",
      //   email: "admin50@gmail.com",
      // });
      currentUserProfile = await User.aggregate([
        {
          $match: { _id: currentUserProfile._id },
        },
        {
          $lookup: {
            from: "tellusabouts",
            localField: "tellUsAbout",
            foreignField: "_id",
            as: "tellUsAboutDetails",
          },
        },
        {
          $unwind: {
            path: "$tellUsAboutDetails",
            // preserveNullAndEmptyArrays: true,
          },
        },
      ]);
    }
    successHandler(res, currentUserProfile);
  } catch (error) {
    errorHandler400(res, error);
  }
};
const updateProfile = async (req, res) => {
  // const profile_picture = req.file;
  const { profile_picture, cover_photo } = req.files;
  let userProfilePicture;
  let userCoverPhoto;
  if (profile_picture) {
    userProfilePicture = await s3ImageUpload(profile_picture[0], "images");
  }if(cover_photo){
    userCoverPhoto = await s3ImageUpload(cover_photo[0], "coverImages");
  }
  // handling profile image here and update from tell us section
  // profileBio______ new Field
  // address______ for coach
  // weight______ tell us
  const currentUser = req.currentUser;
  console.log(currentUser);
  const { fullName, profileBio, email, address, password, weight } = req.body;
  const user = await User.findById(currentUser._id);
  if (user) {
    try {
      user.name = fullName || user.name;
      user.email = email || user.email;
      user.password = password || user.password;
      user.address = address || user.address;
      user.profileBio = profileBio || user.profileBio;
      const updatedUser = await user.save();
      if (updatedUser) {
        await tellUsAbout.findOneAndUpdate(
          { registeredUser: currentUser._id },
          {
            $set: {
              weight: weight,
              ...(userCoverPhoto
                ? { cover_photo: userCoverPhoto.Location }
                : {}),
              ...(userProfilePicture
                ? { profile_picture: userProfilePicture.Location }
                : {}),
            },
          },
          { omitUndefined: true }
        );
        successHandler(res, updatedUser);
      }
    } catch (error) {
      errorHandler400(res, error);
    }
  } else {
    errorHandler400(res, "user not found");
  }
  // with weight, add the profile picture prop
  // await tellUsAbout.findByIdAndUpdate({registeredUser:ObjectId(currentUser._id)}, { weight: weight });
};

const sendVerificationEmail = async (req, res) => {
  let result = req?.currentUser;
  if (!result) return errorHandler401(res, "no user found");
  try {
    // generate Token
    let token = await result.generat_token();
    await result.save();

    let verify_url = `${process.env.BASE_URL}/${
      req.path == "/forgot-password" ? "reset-password" : "verify"
    }/${token}`;
console.log("@5555",  verify_url,result );
    // send email
    const params = {
      verifyURl: verify_url,
      email: result?.email,
      // email: "tayyabmsit@gmail.com",
      subject:
        req.path == "/forgot-password"
          ? "Forgot password"
          : "Longevity email verification",
      html:
        req.path == "/forgot-password"
          ? forgotPassword({ url: verify_url })
          : emailVerification({ url: verify_url }),
    };
    const emailResult = await mailBox(params);
    if (!emailResult.success)
      return errorHandler403(res, emailResult?.error?.details);

    successHandler(res, token);
  } catch (error) {
    console.log("@3333", error);
    errorHandler404(res, error);
  }
};

const verifyEmail = async (req, res) => {

  console.log("verify email endPoint called!")
  const currentUser = req.currentUser;
  try {
    if (!req?.params?.token) return errorHandler401(res, "token not found");
    var encrypt_token = await crypto
      .createHash("sha256")
      .update(req.params.token)
      .digest("hex");
    let user = await User.findOne({
      token: encrypt_token,
      tokenExp: { $gt: Date.now() },
    });
    if (!user) return errorHandler401(res, "invalid Token");
    //  email verify true
    // user.isVerify = true
    user.tokenExp = undefined;
    user.token = undefined;

    // for reset password
    // if (req.path.startsWith('/reset-password')) {
    // 	let { password, confirmPassword } = req.body;
    // 	if (!password || !confirmPassword) return errorHandler401(res, 'password required');
    // 	user.password = password;
    // 	user.confirmPassword = confirmPassword;
    // 	await user.save();
    // 	return successHandler(res, 'Password changed Successfully');
    // }

    await user.save();
    await User.findByIdAndUpdate(user._id, { isEmailVerified: true });
    return successHandler(res, "Verify Successfully");
  } catch (error) {
    console.log("@3333", error);
    return errorHandler404(res, error);
  }
};
const sendInviteToContacts = async (req, res) => {
  const { contactList } = req.body;
  console.log(contactList);
  try {
    const sendInvitation = await sendMessage(
      contactList,
      process.env.TWILIO_APP_INVITATION
    );
    if (sendInvitation.success) {
      successHandler(res, sendInvitation.data);
    }
  } catch (error) {
    errorHandler400(res, error);
  }
};

const nearestUserOnMap = async (req, res) => {
  const currentUser = req?.currentUser;
  if (currentUser.latLng.length < 1)
    return errorHandler404(res, "location not found! field is missing in data");
  try {
    const users = await User.find({
      latLng: {
        $geoWithin: {
          $center: currentUser.latLng,
          $radius: 10000, // 10 kilometers
        },
      },
    });
    successHandler(res, users);
  } catch (error) {
    errorHandler400(res, error);
  }
};
export {
  registerUser,
  updateProfile,
  loginUser,
  coachVerificationController,
  tellUsAboutController,
  sentOTP,
  verifyOTP,
  sendVerificationEmail,
  verifyEmail,
  getProfile,
  sendInviteToContacts,
  nearestUserOnMap,
};
